"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_transformer_core_1 = require("graphql-transformer-core");
var graphql_1 = require("graphql");
var resources_1 = require("./resources");
var graphql_transformer_common_1 = require("graphql-transformer-common");
var fs = require("fs");
var path_1 = require("path");
var AppSyncTransformer = /** @class */ (function (_super) {
    __extends(AppSyncTransformer, _super);
    function AppSyncTransformer(outputPath) {
        var _this = _super.call(this, 'AppSyncTransformer', 'directive @ignore on OBJECT' // TODO: this not a real directive
        ) || this;
        _this.before = function (ctx) {
            // Some downstream resources depend on this so put a placeholder in and
            // overwrite it in the after
            var schemaResource = _this.resources.makeAppSyncSchema('placeholder');
            ctx.setResource(graphql_transformer_common_1.ResourceConstants.RESOURCES.GraphQLSchemaLogicalID, schemaResource);
        };
        _this.after = function (ctx) {
            if (!_this.outputPath) {
                _this.printWithoutFilePath(ctx);
            }
            else {
                _this.printWithFilePath(ctx);
            }
        };
        _this.resources = new resources_1.ResourceFactory();
        if (outputPath) {
            _this.outputPath = path_1.normalize(outputPath);
        }
        return _this;
    }
    AppSyncTransformer.prototype.buildSchema = function (ctx) {
        var mutationNode = ctx.getMutation();
        var queryNode = ctx.getQuery();
        var subscriptionNode = ctx.getSubscription();
        var includeMutation = true;
        var includeQuery = true;
        var includeSubscription = true;
        if (!mutationNode || mutationNode.fields.length === 0) {
            delete ctx.nodeMap.Mutation;
            includeMutation = false;
        }
        if (!queryNode || queryNode.fields.length === 0) {
            delete ctx.nodeMap.Query;
            includeQuery = false;
        }
        if (!subscriptionNode || subscriptionNode.fields.length === 0) {
            delete ctx.nodeMap.Subscription;
            includeSubscription = false;
        }
        var ops = [];
        if (includeQuery) {
            ops.push(graphql_transformer_common_1.makeOperationType('query', queryNode.name.value));
        }
        if (includeMutation) {
            ops.push(graphql_transformer_common_1.makeOperationType('mutation', mutationNode.name.value));
        }
        if (includeSubscription) {
            ops.push(graphql_transformer_common_1.makeOperationType('subscription', subscriptionNode.name.value));
        }
        var schema = graphql_transformer_common_1.makeSchema(ops);
        ctx.putSchema(schema);
        var astSansDirectives = graphql_transformer_core_1.stripDirectives({
            kind: 'Document',
            definitions: Object.keys(ctx.nodeMap).map(function (k) { return ctx.getType(k); })
        }, ['aws_subscribe', 'aws_auth']);
        var SDL = graphql_1.print(astSansDirectives);
        return SDL;
    };
    AppSyncTransformer.prototype.printWithoutFilePath = function (ctx) {
        var SDL = this.buildSchema(ctx);
        var schemaResource = this.resources.makeAppSyncSchema(SDL);
        ctx.setResource(graphql_transformer_common_1.ResourceConstants.RESOURCES.GraphQLSchemaLogicalID, schemaResource);
    };
    AppSyncTransformer.prototype.printWithFilePath = function (ctx) {
        if (!fs.existsSync(this.outputPath)) {
            fs.mkdirSync(this.outputPath);
        }
        var resolverFilePath = path_1.normalize(this.outputPath + '/resolvers');
        if (fs.existsSync(resolverFilePath)) {
            var files = fs.readdirSync(resolverFilePath);
            files.forEach(function (file) { return fs.unlinkSync(resolverFilePath + '/' + file); });
            fs.rmdirSync(resolverFilePath);
        }
        var templateResources = ctx.template.Resources;
        var resolverParams = this.resources.makeResolverS3RootParams();
        ctx.mergeParameters(resolverParams.Parameters);
        for (var _i = 0, _a = Object.keys(templateResources); _i < _a.length; _i++) {
            var resourceName = _a[_i];
            var resource = templateResources[resourceName];
            if (resource.Type === 'AWS::AppSync::Resolver') {
                this.writeResolverToFile(resourceName, ctx);
            }
            else if (resource.Type === 'AWS::Lambda::Function') {
                this.writeLamdbaFunctionToFile(resourceName, ctx);
            }
            else if (resource.Type === 'AWS::AppSync::GraphQLSchema') {
                this.writeSchemaToFile(resourceName, ctx);
            }
        }
    };
    AppSyncTransformer.prototype.writeResolverToFile = function (resourceName, ctx) {
        var resolverFilePath = path_1.normalize(this.outputPath + '/resolvers');
        if (!fs.existsSync(resolverFilePath)) {
            fs.mkdirSync(resolverFilePath);
        }
        var resolverResource = ctx.template.Resources[resourceName];
        var requestMappingTemplate = resolverResource.Properties.RequestMappingTemplate;
        var responseMappingTemplate = resolverResource.Properties.ResponseMappingTemplate;
        // If the templates are not strings. aka they use CF intrinsic functions don't rewrite.
        if (typeof requestMappingTemplate === 'string' &&
            typeof responseMappingTemplate === 'string') {
            var reqType = resolverResource.Properties.TypeName;
            var reqFieldName = resolverResource.Properties.FieldName;
            var reqFileName = reqType + "." + reqFieldName + ".request";
            fs.writeFileSync(resolverFilePath + "/" + reqFileName, requestMappingTemplate);
            var respType = resolverResource.Properties.TypeName;
            var respFieldName = resolverResource.Properties.FieldName;
            var respFileName = respType + "." + respFieldName + ".response";
            fs.writeFileSync(resolverFilePath + "/" + respFileName, responseMappingTemplate);
            var updatedResolverResource = this.resources.updateResolverResource(resolverResource);
            ctx.setResource(resourceName, updatedResolverResource);
        }
    };
    AppSyncTransformer.prototype.writeSchemaToFile = function (resourceName, ctx) {
        var SDL = this.buildSchema(ctx);
        var schemaPath = path_1.normalize(this.outputPath + '/schema.graphql');
        fs.writeFileSync(schemaPath, SDL);
        var schemaParam = this.resources.makeSchemaParam();
        ctx.mergeParameters(schemaParam.Parameters);
        var schemaResource = this.resources.makeAppSyncSchema();
        ctx.setResource(graphql_transformer_common_1.ResourceConstants.RESOURCES.GraphQLSchemaLogicalID, schemaResource);
    };
    AppSyncTransformer.prototype.writeLamdbaFunctionToFile = function (resourceName, ctx) {
        var functionPath = path_1.normalize(this.outputPath + '/functions');
        if (!fs.existsSync(functionPath)) {
            fs.mkdirSync(functionPath);
        }
        var sourcePath = path_1.normalize(ctx.metadata.get('ElasticSearchPathToStreamingLambda'));
        var destPath = path_1.normalize(this.outputPath + "/functions/python_streaming_function.zip");
        var lambdaCode = fs.readFileSync(sourcePath);
        fs.writeFileSync(destPath, lambdaCode);
    };
    return AppSyncTransformer;
}(graphql_transformer_core_1.Transformer));
exports.AppSyncTransformer = AppSyncTransformer;
//# sourceMappingURL=AppSyncTransformer.js.map