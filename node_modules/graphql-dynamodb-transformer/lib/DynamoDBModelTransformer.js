"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_transformer_core_1 = require("graphql-transformer-core");
var resources_1 = require("./resources");
var definitions_1 = require("./definitions");
var graphql_transformer_common_1 = require("graphql-transformer-common");
var graphql_transformer_common_2 = require("graphql-transformer-common");
/**
 * The simple transform.
 *
 * This transform creates a single DynamoDB table for all of your application's
 * data. It uses a standard key structure and nested map to store object values.
 * A relationKey field
 *
 * {
 *  type (HASH),
 *  id (SORT),
 *  value (MAP),
 *  createdAt, (LSI w/ type)
 *  updatedAt (LSI w/ type)
 * }
 */
var DynamoDBModelTransformer = /** @class */ (function (_super) {
    __extends(DynamoDBModelTransformer, _super);
    function DynamoDBModelTransformer() {
        var _this = _super.call(this, 'DynamoDBModelTransformer', "\n            directive @model(\n                queries: ModelQueryMap,\n                mutations: ModelMutationMap,\n                subscriptions: ModelSubscriptionMap\n            ) on OBJECT\n            input ModelMutationMap { create: String, update: String, delete: String }\n            input ModelQueryMap { get: String, list: String }\n            input ModelSubscriptionMap {\n                onCreate: [String]\n                onUpdate: [String]\n                onDelete: [String]\n            }\n            ") || this;
        _this.before = function (ctx) {
            var template = _this.resources.initTemplate();
            ctx.mergeResources(template.Resources);
            ctx.mergeParameters(template.Parameters);
            ctx.mergeOutputs(template.Outputs);
            ctx.mergeConditions(template.Conditions);
        };
        /**
         * Given the initial input and context manipulate the context to handle this object directive.
         * @param initial The input passed to the transform.
         * @param ctx The accumulated context for the transform.
         */
        _this.object = function (def, directive, ctx) {
            // Create the object type.
            // ctx.addObject(def)
            var nonModelArray = definitions_1.getNonModelObjectArray(def, ctx, new Map());
            nonModelArray.forEach(function (value) {
                var nonModelObject = definitions_1.makeNonModelInputObject(value, nonModelArray, ctx);
                if (!_this.typeExist(nonModelObject.name.value, ctx)) {
                    ctx.addInput(nonModelObject);
                }
            });
            // Create the dynamodb table to hold the @model type
            // TODO: Handle types with more than a single "id" hash key
            var typeName = def.name.value;
            var tableLogicalID = graphql_transformer_common_2.ModelResourceIDs.ModelTableResourceID(typeName);
            var iamRoleLogicalID = graphql_transformer_common_2.ModelResourceIDs.ModelTableIAMRoleID(typeName);
            ctx.setResource(tableLogicalID, _this.resources.makeModelTable(typeName));
            ctx.setResource(iamRoleLogicalID, _this.resources.makeIAMRole(tableLogicalID));
            ctx.setResource(graphql_transformer_common_2.ModelResourceIDs.ModelTableDataSourceID(typeName), _this.resources.makeDynamoDBDataSource(tableLogicalID, iamRoleLogicalID));
            _this.createQueries(def, directive, ctx);
            _this.createMutations(def, directive, ctx, nonModelArray);
            _this.createSubscriptions(def, directive, ctx);
        };
        _this.createMutations = function (def, directive, ctx, nonModelArray) {
            var typeName = def.name.value;
            // Create the input types.
            var createInput = definitions_1.makeCreateInputObject(def, nonModelArray, ctx);
            var updateInput = definitions_1.makeUpdateInputObject(def, nonModelArray, ctx);
            var deleteInput = definitions_1.makeDeleteInputObject(def);
            ctx.addInput(createInput);
            ctx.addInput(updateInput);
            ctx.addInput(deleteInput);
            var mutationFields = [];
            // Get any name overrides provided by the user. If an empty map it provided
            // then we do not generate those fields.
            var directiveArguments = _super.prototype.getDirectiveArgumentMap.call(_this, directive);
            // Configure mutations based on *mutations* argument
            var shouldMakeCreate = true;
            var shouldMakeUpdate = true;
            var shouldMakeDelete = true;
            var createFieldNameOverride = undefined;
            var updateFieldNameOverride = undefined;
            var deleteFieldNameOverride = undefined;
            // Figure out which mutations to make and if they have name overrides
            if (directiveArguments.mutations === null) {
                shouldMakeCreate = false;
                shouldMakeUpdate = false;
                shouldMakeDelete = false;
            }
            else if (directiveArguments.mutations) {
                if (!directiveArguments.mutations.create) {
                    shouldMakeCreate = false;
                }
                else {
                    createFieldNameOverride = directiveArguments.mutations.create;
                }
                if (!directiveArguments.mutations.update) {
                    shouldMakeUpdate = false;
                }
                else {
                    updateFieldNameOverride = directiveArguments.mutations.update;
                }
                if (!directiveArguments.mutations.delete) {
                    shouldMakeDelete = false;
                }
                else {
                    deleteFieldNameOverride = directiveArguments.mutations.delete;
                }
            }
            // Create the mutations.
            if (shouldMakeCreate) {
                var createResolver = _this.resources.makeCreateResolver(def.name.value, createFieldNameOverride);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBCreateResolverResourceID(typeName), createResolver);
                mutationFields.push(graphql_transformer_common_1.makeField(createResolver.Properties.FieldName, [graphql_transformer_common_1.makeInputValueDefinition('input', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(createInput.name.value)))], graphql_transformer_common_1.makeNamedType(def.name.value)));
            }
            if (shouldMakeUpdate) {
                var updateResolver = _this.resources.makeUpdateResolver(def.name.value, updateFieldNameOverride);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBUpdateResolverResourceID(typeName), updateResolver);
                mutationFields.push(graphql_transformer_common_1.makeField(updateResolver.Properties.FieldName, [graphql_transformer_common_1.makeInputValueDefinition('input', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(updateInput.name.value)))], graphql_transformer_common_1.makeNamedType(def.name.value)));
            }
            if (shouldMakeDelete) {
                var deleteResolver = _this.resources.makeDeleteResolver(def.name.value, deleteFieldNameOverride);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBDeleteResolverResourceID(typeName), deleteResolver);
                mutationFields.push(graphql_transformer_common_1.makeField(deleteResolver.Properties.FieldName, [graphql_transformer_common_1.makeInputValueDefinition('input', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(deleteInput.name.value)))], graphql_transformer_common_1.makeNamedType(def.name.value)));
            }
            ctx.addMutationFields(mutationFields);
        };
        _this.createQueries = function (def, directive, ctx) {
            var typeName = def.name.value;
            var queryFields = [];
            var directiveArguments = _this.getDirectiveArgumentMap(directive);
            // Configure queries based on *queries* argument
            var shouldMakeGet = true;
            var shouldMakeList = true;
            var getFieldNameOverride = undefined;
            var listFieldNameOverride = undefined;
            // Figure out which queries to make and if they have name overrides.
            // If queries is undefined (default), create all queries
            // If queries is explicetly set to null, do not create any
            // else if queries is defined, check overrides
            if (directiveArguments.queries === null) {
                shouldMakeGet = false;
                shouldMakeList = false;
            }
            else if (directiveArguments.queries) {
                if (!directiveArguments.queries.get) {
                    shouldMakeGet = false;
                }
                else {
                    getFieldNameOverride = directiveArguments.queries.get;
                }
                if (!directiveArguments.queries.list) {
                    shouldMakeList = false;
                }
                else {
                    listFieldNameOverride = directiveArguments.queries.list;
                }
            }
            if (shouldMakeList) {
                if (!_this.typeExist('ModelSortDirection', ctx)) {
                    var tableSortDirection = definitions_1.makeModelSortDirectionEnumObject();
                    ctx.addEnum(tableSortDirection);
                }
            }
            // Create get queries
            if (shouldMakeGet) {
                var getResolver = _this.resources.makeGetResolver(def.name.value, getFieldNameOverride, ctx.getQueryTypeName());
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBGetResolverResourceID(typeName), getResolver);
                queryFields.push(graphql_transformer_common_1.makeField(getResolver.Properties.FieldName, [graphql_transformer_common_1.makeInputValueDefinition('id', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('ID')))], graphql_transformer_common_1.makeNamedType(def.name.value)));
            }
            if (shouldMakeList) {
                _this.generateModelXConnectionType(ctx, def);
                // Create the list resolver
                var listResolver = _this.resources.makeListResolver(def.name.value, listFieldNameOverride, ctx.getQueryTypeName());
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBListResolverResourceID(typeName), listResolver);
                _this.generateFilterInputs(ctx, def);
                queryFields.push(definitions_1.makeModelScanField(listResolver.Properties.FieldName, def.name.value));
            }
            ctx.addQueryFields(queryFields);
        };
        /**
         * Creates subscriptions for a @model object type. By default creates a subscription for
         * create, update, and delete mutations.
         *
         * Subscriptions are one to many in that a subscription may subscribe to multiple mutations.
         * You may thus provide multiple names of the subscriptions that will be triggered by each
         * mutation.
         *
         * type Post @model(subscriptions: { onCreate: ["onPostCreated", "onFeedUpdated"] }) {
         *      id: ID!
         *      title: String!
         * }
         *
         * will create two subscription fields:
         *
         * type Subscription {
         *      onPostCreated: Post @aws_subscribe(mutations: ["createPost"])
         *      onFeedUpdated: Post @aws_subscribe(mutations: ["createPost"])
         * }
         */
        _this.createSubscriptions = function (def, directive, ctx) {
            var typeName = def.name.value;
            var subscriptionFields = [];
            var directiveArguments = _this.getDirectiveArgumentMap(directive);
            var subscriptionsArgument = directiveArguments.subscriptions;
            var createResolver = ctx.getResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBCreateResolverResourceID(typeName));
            var updateResolver = ctx.getResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBUpdateResolverResourceID(typeName));
            var deleteResolver = ctx.getResource(graphql_transformer_common_2.ResolverResourceIDs.DynamoDBDeleteResolverResourceID(typeName));
            if (subscriptionsArgument === null) {
                return;
            }
            else if (subscriptionsArgument) {
                // Add the custom subscriptions
                var subscriptionToMutationsMap = {};
                var onCreate = subscriptionsArgument.onCreate || [];
                var onUpdate = subscriptionsArgument.onUpdate || [];
                var onDelete = subscriptionsArgument.onDelete || [];
                var subFields = onCreate.concat(onUpdate, onDelete);
                // initialize the reverse lookup
                for (var _i = 0, subFields_1 = subFields; _i < subFields_1.length; _i++) {
                    var field = subFields_1[_i];
                    subscriptionToMutationsMap[field] = [];
                }
                // Add the correct mutation to the lookup
                for (var _a = 0, _b = Object.keys(subscriptionToMutationsMap); _a < _b.length; _a++) {
                    var field = _b[_a];
                    if (onCreate.includes(field) && createResolver) {
                        subscriptionToMutationsMap[field].push(createResolver.Properties.FieldName);
                    }
                    if (onUpdate.includes(field) && updateResolver) {
                        subscriptionToMutationsMap[field].push(updateResolver.Properties.FieldName);
                    }
                    if (onDelete.includes(field) && deleteResolver) {
                        subscriptionToMutationsMap[field].push(deleteResolver.Properties.FieldName);
                    }
                }
                for (var _c = 0, _d = Object.keys(subscriptionToMutationsMap); _c < _d.length; _c++) {
                    var subFieldName = _d[_c];
                    var subField = definitions_1.makeSubscriptionField(subFieldName, typeName, subscriptionToMutationsMap[subFieldName]);
                    subscriptionFields.push(subField);
                }
            }
            else {
                // Add the default subscriptions
                if (createResolver) {
                    var onCreateField = definitions_1.makeSubscriptionField(graphql_transformer_common_2.ModelResourceIDs.ModelOnCreateSubscriptionName(typeName), typeName, [createResolver.Properties.FieldName]);
                    subscriptionFields.push(onCreateField);
                }
                if (updateResolver) {
                    var onUpdateField = definitions_1.makeSubscriptionField(graphql_transformer_common_2.ModelResourceIDs.ModelOnUpdateSubscriptionName(typeName), typeName, [updateResolver.Properties.FieldName]);
                    subscriptionFields.push(onUpdateField);
                }
                if (deleteResolver) {
                    var onDeleteField = definitions_1.makeSubscriptionField(graphql_transformer_common_2.ModelResourceIDs.ModelOnDeleteSubscriptionName(typeName), typeName, [deleteResolver.Properties.FieldName]);
                    subscriptionFields.push(onDeleteField);
                }
            }
            ctx.addSubscriptionFields(subscriptionFields);
        };
        _this.resources = new resources_1.ResourceFactory();
        return _this;
    }
    DynamoDBModelTransformer.prototype.typeExist = function (type, ctx) {
        return Boolean(type in ctx.nodeMap);
    };
    DynamoDBModelTransformer.prototype.generateModelXConnectionType = function (ctx, def) {
        var tableXConnectionName = graphql_transformer_common_2.ModelResourceIDs.ModelConnectionTypeName(def.name.value);
        if (this.typeExist(tableXConnectionName, ctx)) {
            return;
        }
        // Create the ModelXConnection
        var connectionType = graphql_transformer_common_1.blankObject(tableXConnectionName);
        ctx.addObject(connectionType);
        ctx.addObjectExtension(definitions_1.makeModelConnectionType(def.name.value));
    };
    DynamoDBModelTransformer.prototype.generateFilterInputs = function (ctx, def) {
        var scalarFilters = definitions_1.makeScalarFilterInputs();
        for (var _i = 0, scalarFilters_1 = scalarFilters; _i < scalarFilters_1.length; _i++) {
            var filter = scalarFilters_1[_i];
            if (!this.typeExist(filter.name.value, ctx)) {
                ctx.addInput(filter);
            }
        }
        // Create the ModelXFilterInput
        var tableXQueryFilterInput = definitions_1.makeModelXFilterInputObject(def);
        if (!this.typeExist(tableXQueryFilterInput.name.value, ctx)) {
            ctx.addInput(tableXQueryFilterInput);
        }
    };
    return DynamoDBModelTransformer;
}(graphql_transformer_core_1.Transformer));
exports.DynamoDBModelTransformer = DynamoDBModelTransformer;
//# sourceMappingURL=DynamoDBModelTransformer.js.map