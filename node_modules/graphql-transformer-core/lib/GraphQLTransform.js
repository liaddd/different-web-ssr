"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var TransformerContext_1 = require("./TransformerContext");
var blankTemplate_1 = require("./util/blankTemplate");
var errors_1 = require("./errors");
var validation_1 = require("./validation");
function isFunction(obj) {
    return obj && (typeof obj === 'function');
}
function makeSeenTransformationKey(directive, type, field, arg) {
    if (directive && type && field && arg) {
        return type.name.value + "." + field.name.value + "." + arg.name.value + "@" + directive.name.value;
    }
    if (directive && type && field) {
        return type.name.value + "." + field.name.value + "@" + directive.name.value;
    }
    else {
        return type.name.value + "@" + directive.name.value;
    }
}
/**
 * If this instance of the directive validates against its definition return true.
 * If the definition does not apply to the instance return false.
 * @param directive The directive definition to validate against.
 * @param nodeKind The kind of the current node where the directive was found.
 */
function matchDirective(definition, directive, node) {
    if (!directive) {
        return false;
    }
    if (definition.name.value !== directive.name.value) {
        // The definition is for the wrong directive. Do not match.
        return false;
    }
    var isValidLocation = false;
    for (var _i = 0, _a = definition.locations; _i < _a.length; _i++) {
        var location_1 = _a[_i];
        switch (location_1.value) {
            case "SCHEMA":
                isValidLocation = node.kind === graphql_1.Kind.SCHEMA_DEFINITION || isValidLocation;
                break;
            case "SCALAR":
                isValidLocation = node.kind === graphql_1.Kind.SCALAR_TYPE_DEFINITION || isValidLocation;
                break;
            case "OBJECT":
                isValidLocation = node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case "FIELD_DEFINITION":
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            case "ARGUMENT_DEFINITION":
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            case "INTERFACE":
                isValidLocation = node.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || isValidLocation;
                break;
            case "UNION":
                isValidLocation = node.kind === graphql_1.Kind.UNION_TYPE_DEFINITION || isValidLocation;
                break;
            case "ENUM":
                isValidLocation = node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION || isValidLocation;
                break;
            case "ENUM_VALUE":
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            case "INPUT_OBJECT":
                isValidLocation = node.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case "INPUT_FIELD_DEFINITION":
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
        }
    }
    return isValidLocation;
}
function matchFieldDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        // The definition is for the wrong directive. Do not match.
        return false;
    }
    var isValidLocation = false;
    for (var _i = 0, _a = definition.locations; _i < _a.length; _i++) {
        var location_2 = _a[_i];
        switch (location_2.value) {
            case "FIELD_DEFINITION":
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
        }
    }
    return isValidLocation;
}
function matchInputFieldDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        // The definition is for the wrong directive. Do not match.
        return false;
    }
    var isValidLocation = false;
    for (var _i = 0, _a = definition.locations; _i < _a.length; _i++) {
        var location_3 = _a[_i];
        switch (location_3.value) {
            case "INPUT_FIELD_DEFINITION":
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
        }
    }
    return isValidLocation;
}
function matchArgumentDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        // The definition is for the wrong directive. Do not match.
        return false;
    }
    var isValidLocation = false;
    for (var _i = 0, _a = definition.locations; _i < _a.length; _i++) {
        var location_4 = _a[_i];
        switch (location_4.value) {
            case "ARGUMENT_DEFINITION":
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
        }
    }
    return isValidLocation;
}
function matchEnumValueDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        // The definition is for the wrong directive. Do not match.
        return false;
    }
    var isValidLocation = false;
    for (var _i = 0, _a = definition.locations; _i < _a.length; _i++) {
        var location_5 = _a[_i];
        switch (location_5.value) {
            case "ENUM_VALUE":
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
        }
    }
    return isValidLocation;
}
var GraphQLTransform = /** @class */ (function () {
    function GraphQLTransform(options) {
        // A map from `${directive}.${typename}.${fieldName?}`: true
        // that specifies we have run already run a directive at a given location.
        // Only run a transformer function once per pair. This is refreshed each call to transform().
        this.seenTransformations = {};
        if (!options.transformers || options.transformers.length === 0) {
            throw new Error('Must provide at least one transformer.');
        }
        this.transformers = options.transformers;
    }
    /**
     * Reduces the final context by running the set of transformers on
     * the schema. Each transformer returns a new context that is passed
     * on to the next transformer. At the end of the transformation a
     * cloudformation template is returned.
     * @param schema The model schema.
     * @param references Any cloudformation references.
     */
    GraphQLTransform.prototype.transform = function (schema, template) {
        if (template === void 0) { template = blankTemplate_1.default(); }
        this.seenTransformations = {};
        var context = new TransformerContext_1.default(schema);
        var validDirectiveNameMap = this.transformers.reduce(function (acc, t) {
            var _a;
            return (__assign({}, acc, (_a = {}, _a[t.directive.name.value] = true, _a)));
        }, { aws_subscribe: true, aws_auth: true });
        var allModelDefinitions = context.inputDocument.definitions.slice();
        for (var _i = 0, _a = this.transformers; _i < _a.length; _i++) {
            var transformer = _a[_i];
            allModelDefinitions = allModelDefinitions.concat.apply(allModelDefinitions, transformer.typeDefinitions.concat([transformer.directive]));
        }
        var errors = validation_1.validateModelSchema({ kind: graphql_1.Kind.DOCUMENT, definitions: allModelDefinitions });
        if (errors && errors.length) {
            throw new errors_1.SchemaValidationError(errors.slice(0));
        }
        for (var _b = 0, _c = this.transformers; _b < _c.length; _b++) {
            var transformer = _c[_b];
            if (isFunction(transformer.before)) {
                transformer.before(context);
            }
            // TODO: Validate that the transformer supports all the methods
            // required for the directive definition. Also verify that
            // directives are not used where they are not allowed.
            // Apply each transformer and accumulate the context.
            for (var _d = 0, _e = context.inputDocument.definitions; _d < _e.length; _d++) {
                var def = _e[_d];
                switch (def.kind) {
                    case 'ObjectTypeDefinition':
                        this.transformObject(transformer, def, validDirectiveNameMap, context);
                        // Walk the fields and call field transformers.
                        break;
                    case 'InterfaceTypeDefinition':
                        this.transformInterface(transformer, def, validDirectiveNameMap, context);
                        // Walk the fields and call field transformers.
                        break;
                    case 'ScalarTypeDefinition':
                        this.transformScalar(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'UnionTypeDefinition':
                        this.transformUnion(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'EnumTypeDefinition':
                        this.transformEnum(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'InputObjectTypeDefinition':
                        this.transformInputObject(transformer, def, validDirectiveNameMap, context);
                        break;
                    default:
                        continue;
                }
            }
        }
        // .transform() is meant to behave like a composition so the
        // after functions are called in the reverse order (as if they were popping off a stack)
        var reverseThroughTransformers = this.transformers.length - 1;
        while (reverseThroughTransformers >= 0) {
            var transformer = this.transformers[reverseThroughTransformers];
            // TODO: Validate the new context.
            if (1 !== 1) {
                throw new Error("Invalid context after transformer " + transformer.name);
            }
            if (isFunction(transformer.after)) {
                transformer.after(context);
            }
            reverseThroughTransformers -= 1;
        }
        // Write the schema.
        return context.template;
    };
    GraphQLTransform.prototype.transformObject = function (transformer, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.object)) {
                    var transformKey = makeSeenTransformationKey(dir, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.object(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'object()' method");
                }
            }
        }
        for (var _b = 0, _c = def.fields; _b < _c.length; _b++) {
            var field = _c[_b];
            this.transformField(transformer, def, field, validDirectiveNameMap, context);
        }
    };
    GraphQLTransform.prototype.transformField = function (transformer, parent, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchFieldDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.field)) {
                    var transformKey = makeSeenTransformationKey(dir, parent, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.field(parent, def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'field()' method");
                }
            }
        }
        for (var _b = 0, _c = def.arguments; _b < _c.length; _b++) {
            var arg = _c[_b];
            this.transformArgument(transformer, parent, def, arg, validDirectiveNameMap, context);
        }
    };
    GraphQLTransform.prototype.transformArgument = function (transformer, parent, field, arg, validDirectiveNameMap, context) {
        for (var _i = 0, _a = arg.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchArgumentDirective(transformer.directive, dir, arg)) {
                if (isFunction(transformer.argument)) {
                    var transformKey = makeSeenTransformationKey(dir, parent, field, arg);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.argument(arg, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'argument()' method");
                }
            }
        }
    };
    GraphQLTransform.prototype.transformInterface = function (transformer, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.interface)) {
                    var transformKey = makeSeenTransformationKey(dir, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.interface(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'interface()' method");
                }
            }
        }
        for (var _b = 0, _c = def.fields; _b < _c.length; _b++) {
            var field = _c[_b];
            this.transformField(transformer, def, field, validDirectiveNameMap, context);
        }
    };
    GraphQLTransform.prototype.transformScalar = function (transformer, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.scalar)) {
                    var transformKey = makeSeenTransformationKey(dir, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.scalar(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'scalar()' method");
                }
            }
        }
    };
    GraphQLTransform.prototype.transformUnion = function (transformer, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.union)) {
                    var transformKey = makeSeenTransformationKey(dir, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.union(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'union()' method");
                }
            }
        }
    };
    GraphQLTransform.prototype.transformEnum = function (transformer, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.enum)) {
                    var transformKey = makeSeenTransformationKey(dir, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.enum(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'enum()' method");
                }
            }
        }
        for (var _b = 0, _c = def.values; _b < _c.length; _b++) {
            var value = _c[_b];
            this.transformEnumValue(transformer, def, value, validDirectiveNameMap, context);
        }
    };
    GraphQLTransform.prototype.transformEnumValue = function (transformer, enm, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchEnumValueDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.enumValue)) {
                    var transformKey = makeSeenTransformationKey(dir, enm, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.enumValue(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'enumValue()' method");
                }
            }
        }
    };
    GraphQLTransform.prototype.transformInputObject = function (transformer, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.input)) {
                    var transformKey = makeSeenTransformationKey(dir, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.input(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'input()' method");
                }
            }
        }
        for (var _b = 0, _c = def.fields; _b < _c.length; _b++) {
            var field = _c[_b];
            this.transformInputField(transformer, def, field, validDirectiveNameMap, context);
        }
    };
    GraphQLTransform.prototype.transformInputField = function (transformer, input, def, validDirectiveNameMap, context) {
        for (var _i = 0, _a = def.directives; _i < _a.length; _i++) {
            var dir = _a[_i];
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError("Unknown directive '" + dir.name.value + "'. Either remove the directive from the schema or add a transformer to handle it.");
            }
            if (matchInputFieldDirective(transformer.directive, dir, def)) {
                if (isFunction(transformer.inputValue)) {
                    var transformKey = makeSeenTransformationKey(dir, input, def);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.inputValue(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError("The transformer '" + transformer.name + "' must implement the 'inputValue()' method");
                }
            }
        }
    };
    return GraphQLTransform;
}());
exports.default = GraphQLTransform;
//# sourceMappingURL=GraphQLTransform.js.map