import Template from 'cloudform/types/template';
import Resource from 'cloudform/types/resource';
import Parameter from 'cloudform/types/parameter';
import { Condition } from 'cloudform/types/dataTypes';
import Output from 'cloudform/types/output';
import { TypeSystemDefinitionNode, ObjectTypeDefinitionNode, FieldDefinitionNode, InputObjectTypeDefinitionNode, SchemaDefinitionNode, ObjectTypeExtensionNode, DocumentNode, EnumTypeDefinitionNode, TypeDefinitionNode } from 'graphql';
export declare function blankObject(name: string): ObjectTypeDefinitionNode;
export declare function objectExtension(name: string, fields?: FieldDefinitionNode[]): ObjectTypeExtensionNode;
export declare class TransformerContextMetadata {
    /**
     * Used by transformers to pass information between one another.
     */
    private metadata;
    get(key: string): any;
    set(key: string, val: any): void;
    has(key: string): boolean;
}
/**
 * The transformer context is responsible for accumulating the resources,
 * types, and parameters necessary to support an AppSync transform.
 */
export default class TransformerContext {
    template: Template;
    nodeMap: {
        [name: string]: TypeSystemDefinitionNode;
    };
    inputDocument: DocumentNode;
    metadata: TransformerContextMetadata;
    constructor(inputSDL: string);
    /**
     * Before running the transformers, first flush the input document
     * into the node map. If a schema definition node then leave everything
     * as is so customers can explicitly turn off mutations & subscriptions.
     * If a SDN is not provided then we add the default schema and empty
     * Query, Mutation, and Subscription
     */
    private fillNodeMapWithInput;
    mergeResources(resources: {
        [key: string]: Resource;
    }): void;
    mergeParameters(params: {
        [key: string]: Parameter;
    }): void;
    mergeConditions(conditions: {
        [key: string]: Condition;
    }): void;
    getResource(resource: string): Resource;
    setResource(key: string, resource: Resource): void;
    setOutput(key: string, output: Output): void;
    getOutput(key: string): Output;
    mergeOutputs(outputs: {
        [key: string]: Output;
    }): void;
    /**
     * Add an object type definition node to the context. If the type already
     * exists an error will be thrown.
     * @param obj The object type definition node to add.
     */
    putSchema(obj: SchemaDefinitionNode): void;
    /**
     * Returns the schema definition record. If the user provides a schema
     * definition as part of the input document, that node is returned.
     * Otherwise a blank schema definition with default operation types
     * is returned.
     */
    getSchema(): SchemaDefinitionNode;
    getQueryTypeName(): string | undefined;
    getQuery(): ObjectTypeDefinitionNode | undefined;
    getMutationTypeName(): string | undefined;
    getMutation(): ObjectTypeDefinitionNode | undefined;
    getSubscriptionTypeName(): string | undefined;
    getSubscription(): ObjectTypeDefinitionNode | undefined;
    /**
     * Add a generic type.
     * @param obj The type to add
     */
    addType(obj: TypeDefinitionNode): void;
    putType(obj: TypeDefinitionNode): void;
    getType(name: string): TypeSystemDefinitionNode | undefined;
    /**
     * Add an object type definition node to the context. If the type already
     * exists an error will be thrown.
     * @param obj The object type definition node to add.
     */
    addObject(obj: ObjectTypeDefinitionNode): void;
    getObject(name: string): ObjectTypeDefinitionNode | undefined;
    /**
     * Extends the context query object with additional fields.
     * If the customer uses a name other than 'Query' this will proxy to the
     * correct type.
     * @param fields The fields to add the query type.
     */
    addQueryFields(fields: FieldDefinitionNode[]): void;
    /**
     * Extends the context mutation object with additional fields.
     * If the customer uses a name other than 'Mutation' this will proxy to the
     * correct type.
     * @param fields The fields to add the mutation type.
     */
    addMutationFields(fields: FieldDefinitionNode[]): void;
    /**
     * Extends the context subscription object with additional fields.
     * If the customer uses a name other than 'Subscription' this will proxy to the
     * correct type.
     * @param fields The fields to add the subscription type.
     */
    addSubscriptionFields(fields: FieldDefinitionNode[]): void;
    /**
     * Add an object type extension definition node to the context. If a type with this
     * name does not already exist, an exception is thrown.
     * @param obj The object type definition node to add.
     */
    addObjectExtension(obj: ObjectTypeExtensionNode): void;
    /**
     * Add an input type definition node to the context.
     * @param inp The input type definition node to add.
     */
    addInput(inp: InputObjectTypeDefinitionNode): void;
    /**
     * Add an enum type definition node to the context.
     * @param en The enum type definition node to add.
     */
    addEnum(en: EnumTypeDefinitionNode): void;
}
