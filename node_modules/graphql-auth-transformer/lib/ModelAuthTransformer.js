"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_transformer_core_1 = require("graphql-transformer-core");
var resources_1 = require("./resources");
var graphql_transformer_common_1 = require("graphql-transformer-common");
var graphql_mapping_template_1 = require("graphql-mapping-template");
var graphql_1 = require("graphql");
/**
 * Implements the ModelAuthTransformer.
 *
 * Owner Auth Usage:
 *
 * type Post @auth(allow: owner) {
 *   id: ID!
 *   title: String
 *   createdAt: String
 *   updatedAt: String
 * }
 *
 * Impact:
 *
 * getPost - In the response mapping template we check the "owner" field === $ctx.identity.username.
 * listPost - In the response mapping template we return only items where "owner" === $ctx.identity.username
 * createPost - We automatically insert a "owner" field to attribute values where "owner" === $ctx.identity.username.
 * updatePost - Expose "owner" field in input/output and would set conditional update expression to look for owner.
 * deletePost - Conditional expression checking that the owner === $ctx.identity.username
 *
 * Note: The name of the "owner" field may be configured via the CF paramaters.
 *
 * type Post @auth(allow: groups, groups: ["Admin", "Dev"]) {
 *   id: ID!
 *   title: String
 *   createdAt: String
 *   updatedAt: String
 * }
 *
 * Impact:
 *
 * getPost - Update req template to look for the groups in the identity.
 * listPost - Update req template to look for the groups in the identity.
 * createPost - Update req template to look for the groups in the identity.
 * updatePost - Update req template to look for the groups in the identity.
 * deletePost - Update req template to look for the groups in the identity.
 *
 * TODO: Document support for dynamic group authorization against
 * attributes of the records using conditional expressions. This will likely
 * be via a new argument such as "groupsField".
 */
var ModelAuthTransformer = /** @class */ (function (_super) {
    __extends(ModelAuthTransformer, _super);
    function ModelAuthTransformer() {
        var _this = _super.call(this, 'ModelAuthTransformer', "\n            directive @auth(rules: [AuthRule!]!) on OBJECT\n            input AuthRule {\n                allow: AuthStrategy!\n                ownerField: String # defaults to \"owner\"\n                identityField: String # defaults to \"cognito:username\"\n                groupsField: String\n                groups: [String]\n                queries: [ModelQuery]\n                mutations: [ModelMutation]\n            }\n            enum AuthStrategy { owner groups }\n            enum ModelQuery { get list }\n            enum ModelMutation { create update delete }\n            ") || this;
        /**
         * Updates the GraphQL API record to use user pool auth.
         */
        _this.updateAPIForUserPools = function (ctx) {
            var apiRecord = ctx.getResource(graphql_transformer_common_1.ResourceConstants.RESOURCES.GraphQLAPILogicalID);
            var updated = _this.resources.updateGraphQLAPIWithAuth(apiRecord);
            ctx.setResource(graphql_transformer_common_1.ResourceConstants.RESOURCES.GraphQLAPILogicalID, updated);
        };
        _this.before = function (ctx) {
            var template = _this.resources.initTemplate();
            ctx.mergeResources(template.Resources);
            ctx.mergeParameters(template.Parameters);
            ctx.mergeOutputs(template.Outputs);
            ctx.mergeConditions(template.Conditions);
            _this.updateAPIForUserPools(ctx);
        };
        /**
         * Implement the transform for an object type. Depending on which operations are to be protected
         */
        _this.object = function (def, directive, ctx) {
            var get = function (s) { return function (arg) { return arg.name.value === s; }; };
            var getArg = function (arg, dflt) {
                var argument = directive.arguments.find(get(arg));
                return argument ? graphql_1.valueFromASTUntyped(argument.value) : dflt;
            };
            var modelDirective = def.directives.find(function (dir) { return dir.name.value === 'model'; });
            if (!modelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('Types annotated with @auth must also be annotated with @model.');
            }
            // Get the auth rules.
            var rules = getArg('rules', []);
            // Create a reverse index on rules from operation -> rules list.
            var queryRules = {
                get: [],
                list: [],
            };
            var mutationRules = {
                create: [],
                update: [],
                delete: []
            };
            var matchQuery = function (op) { return function (rule) {
                if (rule.queries) {
                    var matchesOp = rule.queries.find(function (o) { return o === op; });
                    return Boolean(matchesOp);
                }
                else if (rule.queries === null) {
                    return false;
                }
                return true;
            }; };
            var matchMutation = function (op) { return function (rule) {
                if (rule.mutations) {
                    var matchesOp = rule.mutations.find(function (o) { return o === op; });
                    return Boolean(matchesOp);
                }
                else if (rule.mutations === null) {
                    return false;
                }
                return true;
            }; };
            for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
                var rule = rules_1[_i];
                if (matchQuery('get')(rule)) {
                    queryRules.get.push(rule);
                }
                if (matchQuery('list')(rule)) {
                    queryRules.list.push(rule);
                }
                if (matchMutation('create')(rule)) {
                    mutationRules.create.push(rule);
                }
                if (matchMutation('update')(rule)) {
                    mutationRules.update.push(rule);
                }
                if (matchMutation('delete')(rule)) {
                    mutationRules.delete.push(rule);
                }
            }
            // For each operation evaluate the rules and apply the changes to the relevant resolver.
            _this.protectCreateMutation(ctx, graphql_transformer_common_1.ResolverResourceIDs.DynamoDBCreateResolverResourceID(def.name.value), mutationRules.create, def);
            _this.protectUpdateMutation(ctx, graphql_transformer_common_1.ResolverResourceIDs.DynamoDBUpdateResolverResourceID(def.name.value), mutationRules.update, def);
            _this.protectDeleteMutation(ctx, graphql_transformer_common_1.ResolverResourceIDs.DynamoDBDeleteResolverResourceID(def.name.value), mutationRules.delete, def);
            _this.protectGetQuery(ctx, graphql_transformer_common_1.ResolverResourceIDs.DynamoDBGetResolverResourceID(def.name.value), queryRules.get);
            _this.protectListQuery(ctx, graphql_transformer_common_1.ResolverResourceIDs.DynamoDBListResolverResourceID(def.name.value), queryRules.list);
        };
        _this.resources = new resources_1.ResourceFactory();
        return _this;
    }
    /**
     * Protect get queries.
     * If static group:
     *  If statically authorized then allow the operation. Stop.
     * If owner and/or dynamic group:
     *  If the result item satisfies the owner/group authorization condition
     *  then allow it.
     * @param ctx The transformer context.
     * @param resolverResourceId The logical id of the get resolver.
     * @param rules The auth rules to apply.
     */
    ModelAuthTransformer.prototype.protectGetQuery = function (ctx, resolverResourceId, rules) {
        var resolver = ctx.getResource(resolverResourceId);
        if (!rules || rules.length === 0 || !resolver) {
            return;
        }
        else {
            // Break the rules out by strategy.
            var staticGroupAuthorizationRules = this.getStaticGroupRules(rules);
            var dynamicGroupAuthorizationRules = this.getDynamicGroupRules(rules);
            var ownerAuthorizationRules = this.getOwnerRules(rules);
            // Generate the expressions to validate each strategy.
            var staticGroupAuthorizationExpression = this.resources.staticGroupAuthorizationExpression(staticGroupAuthorizationRules);
            var dynamicGroupAuthorizationExpression = this.resources.dynamicGroupAuthorizationExpressionForReadOperations(dynamicGroupAuthorizationRules);
            var ownerAuthorizationExpression = this.resources.ownerAuthorizationExpressionForReadOperations(ownerAuthorizationRules);
            var throwIfUnauthorizedExpression = this.resources.throwIfUnauthorized();
            // Update the existing resolver with the authorization checks.
            var responseMappingTemplatePrefixExpressions = [
                staticGroupAuthorizationExpression,
                graphql_mapping_template_1.newline(),
                dynamicGroupAuthorizationExpression,
                graphql_mapping_template_1.newline(),
                ownerAuthorizationExpression,
                graphql_mapping_template_1.newline(),
                throwIfUnauthorizedExpression
            ];
            var templateParts = [
                graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression(responseMappingTemplatePrefixExpressions)),
                resolver.Properties.ResponseMappingTemplate
            ];
            resolver.Properties.ResponseMappingTemplate = templateParts.join('\n\n');
            ctx.setResource(resolverResourceId, resolver);
        }
    };
    /**
     * Protect list queries.
     * If static group:
     *  If the user is statically authorized then return items and stop.
     * If dynamic group and/or owner:
     *  Loop through all items and find items that satisfy any of the group or
     *  owner conditions.
     * @param ctx The transformer context.
     * @param resolverResourceId The logical id of the resolver to be updated in the CF template.
     * @param rules The set of rules that apply to the operation.
     */
    ModelAuthTransformer.prototype.protectListQuery = function (ctx, resolverResourceId, rules) {
        var resolver = ctx.getResource(resolverResourceId);
        if (!rules || rules.length === 0 || !resolver) {
            return;
        }
        else {
            // Break the rules out by strategy.
            var staticGroupAuthorizationRules = this.getStaticGroupRules(rules);
            var dynamicGroupAuthorizationRules = this.getDynamicGroupRules(rules);
            var ownerAuthorizationRules = this.getOwnerRules(rules);
            // Generate the expressions to validate each strategy.
            var staticGroupAuthorizationExpression = this.resources.staticGroupAuthorizationExpression(staticGroupAuthorizationRules);
            // In list queries, the dynamic group and ownership authorization checks
            // occur on a per item basis. The helpers take the variable names
            // as parameters to allow for this use case.
            var dynamicGroupAuthorizationExpression = this.resources.dynamicGroupAuthorizationExpressionForReadOperations(dynamicGroupAuthorizationRules, 'item', graphql_transformer_common_1.ResourceConstants.SNIPPETS.IsLocalDynamicGroupAuthorizedVariable, graphql_mapping_template_1.raw("false"));
            var ownerAuthorizationExpression = this.resources.ownerAuthorizationExpressionForReadOperations(ownerAuthorizationRules, 'item', graphql_transformer_common_1.ResourceConstants.SNIPPETS.IsLocalOwnerAuthorizedVariable, graphql_mapping_template_1.raw("false"));
            var appendIfLocallyAuthorized = this.resources.appendItemIfLocallyAuthorized();
            var ifNotStaticallyAuthedFilterObjects = graphql_mapping_template_1.iff(graphql_mapping_template_1.raw("! $" + graphql_transformer_common_1.ResourceConstants.SNIPPETS.IsStaticGroupAuthorizedVariable), graphql_mapping_template_1.compoundExpression([
                graphql_mapping_template_1.set(graphql_mapping_template_1.ref('items'), graphql_mapping_template_1.list([])),
                graphql_mapping_template_1.forEach(graphql_mapping_template_1.ref('item'), graphql_mapping_template_1.ref('ctx.result.items'), [
                    dynamicGroupAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    ownerAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    appendIfLocallyAuthorized
                ]),
                graphql_mapping_template_1.set(graphql_mapping_template_1.ref('ctx.result.items'), graphql_mapping_template_1.ref('items'))
            ]));
            var templateParts = [
                graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression([
                    staticGroupAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    graphql_mapping_template_1.comment('[Start] If not static group authorized, filter items'),
                    ifNotStaticallyAuthedFilterObjects,
                    graphql_mapping_template_1.comment('[End] If not static group authorized, filter items')
                ])),
                resolver.Properties.ResponseMappingTemplate
            ];
            resolver.Properties.ResponseMappingTemplate = templateParts.join('\n\n');
            ctx.setResource(resolverResourceId, resolver);
        }
    };
    /**
     * Inject auth rules for create mutations.
     * If owner auth:
     *  If the owner field exists in the input, validate that it against the identity.
     *  If the owner field dne in the input, insert the identity.
     * If group:
     *  If the user is static group authorized allow operation no matter what.
     *  If dynamic group and the input defines a group(s) validate it against the identity.
     * @param ctx
     * @param resolverResourceId
     * @param rules
     */
    ModelAuthTransformer.prototype.protectCreateMutation = function (ctx, resolverResourceId, rules, parent) {
        var resolver = ctx.getResource(resolverResourceId);
        if (!rules || rules.length === 0 || !resolver) {
            return;
        }
        else {
            // Break the rules out by strategy.
            var staticGroupAuthorizationRules = this.getStaticGroupRules(rules);
            var dynamicGroupAuthorizationRules = this.getDynamicGroupRules(rules);
            var ownerAuthorizationRules = this.getOwnerRules(rules);
            // Generate the expressions to validate each strategy.
            var staticGroupAuthorizationExpression = this.resources.staticGroupAuthorizationExpression(staticGroupAuthorizationRules);
            // In create mutations, the dynamic group and ownership authorization checks
            // are done before calling PutItem.
            var dynamicGroupAuthorizationExpression = this.resources.dynamicGroupAuthorizationExpressionForCreateOperations(dynamicGroupAuthorizationRules);
            var fieldIsList = function (fieldName) {
                var field = parent.fields.find(function (field) { return field.name.value === fieldName; });
                if (field) {
                    return graphql_transformer_common_1.isListType(field.type);
                }
                return false;
            };
            var ownerAuthorizationExpression = this.resources.ownerAuthorizationExpressionForCreateOperations(ownerAuthorizationRules, fieldIsList);
            var throwIfUnauthorizedExpression = this.resources.throwIfUnauthorized();
            var templateParts = [
                graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression([
                    staticGroupAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    dynamicGroupAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    ownerAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    throwIfUnauthorizedExpression
                ])),
                resolver.Properties.RequestMappingTemplate
            ];
            resolver.Properties.RequestMappingTemplate = templateParts.join('\n\n');
            ctx.setResource(resolverResourceId, resolver);
        }
    };
    /**
     * Protect update and delete mutations.
     * If Owner:
     *  Update the conditional expression such that the update only works if
     *  the user is the owner.
     * If dynamic group:
     *  Update the conditional expression such that it succeeds if the user is
     *  dynamic group authorized. If the operation is also owner authorized this
     *  should be joined with an OR expression.
     * If static group:
     *  If the user is statically authorized then allow no matter what. This can
     *  be done by removing the conditional expression as long as static group
     *  auth is always checked last.
     * @param ctx The transformer context.
     * @param resolverResourceId The logical id of the resolver in the template.
     * @param rules The list of rules to apply.
     */
    ModelAuthTransformer.prototype.protectUpdateOrDeleteMutation = function (ctx, resolverResourceId, rules, parent) {
        var resolver = ctx.getResource(resolverResourceId);
        if (!rules || rules.length === 0 || !resolver) {
            return;
        }
        else {
            // Break the rules out by strategy.
            var staticGroupAuthorizationRules = this.getStaticGroupRules(rules);
            var dynamicGroupAuthorizationRules = this.getDynamicGroupRules(rules);
            var ownerAuthorizationRules = this.getOwnerRules(rules);
            // Generate the expressions to validate each strategy.
            var staticGroupAuthorizationExpression = this.resources.staticGroupAuthorizationExpression(staticGroupAuthorizationRules);
            // In create mutations, the dynamic group and ownership authorization checks
            // are done before calling PutItem.
            var dynamicGroupAuthorizationExpression = this.resources.dynamicGroupAuthorizationExpressionForUpdateOrDeleteOperations(dynamicGroupAuthorizationRules);
            var fieldIsList = function (fieldName) {
                var field = parent.fields.find(function (field) { return field.name.value === fieldName; });
                if (field) {
                    return graphql_transformer_common_1.isListType(field.type);
                }
                return false;
            };
            var ownerAuthorizationExpression = this.resources.ownerAuthorizationExpressionForUpdateOrDeleteOperations(ownerAuthorizationRules, fieldIsList);
            var collectAuthCondition = this.resources.collectAuthCondition();
            var ifNotStaticallyAuthedCreateAuthCondition = graphql_mapping_template_1.iff(graphql_mapping_template_1.raw("! $" + graphql_transformer_common_1.ResourceConstants.SNIPPETS.IsStaticGroupAuthorizedVariable), graphql_mapping_template_1.compoundExpression([
                dynamicGroupAuthorizationExpression,
                graphql_mapping_template_1.newline(),
                ownerAuthorizationExpression,
                graphql_mapping_template_1.newline(),
                collectAuthCondition
            ]));
            var throwIfNotStaticGroupAuthorizedOrAuthConditionIsEmpty = this.resources.throwIfNotStaticGroupAuthorizedOrAuthConditionIsEmpty();
            var templateParts = [
                graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression([
                    staticGroupAuthorizationExpression,
                    graphql_mapping_template_1.newline(),
                    ifNotStaticallyAuthedCreateAuthCondition,
                    graphql_mapping_template_1.newline(),
                    throwIfNotStaticGroupAuthorizedOrAuthConditionIsEmpty
                ])),
                resolver.Properties.RequestMappingTemplate
            ];
            resolver.Properties.RequestMappingTemplate = templateParts.join('\n\n');
            ctx.setResource(resolverResourceId, resolver);
        }
    };
    ModelAuthTransformer.prototype.protectUpdateMutation = function (ctx, resolverResourceId, rules, parent) {
        return this.protectUpdateOrDeleteMutation(ctx, resolverResourceId, rules, parent);
    };
    ModelAuthTransformer.prototype.protectDeleteMutation = function (ctx, resolverResourceId, rules, parent) {
        return this.protectUpdateOrDeleteMutation(ctx, resolverResourceId, rules, parent);
    };
    ModelAuthTransformer.prototype.getOwnerRules = function (rules) {
        return rules.filter(function (rule) { return rule.allow === 'owner'; });
    };
    ModelAuthTransformer.prototype.getStaticGroupRules = function (rules) {
        return rules.filter(function (rule) { return rule.allow === 'groups' && Boolean(rule.groups); });
    };
    ModelAuthTransformer.prototype.getDynamicGroupRules = function (rules) {
        return rules.filter(function (rule) { return rule.allow === 'groups' && !Boolean(rule.groups); });
    };
    return ModelAuthTransformer;
}(graphql_transformer_core_1.Transformer));
exports.ModelAuthTransformer = ModelAuthTransformer;
//# sourceMappingURL=ModelAuthTransformer.js.map