"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_transformer_core_1 = require("graphql-transformer-core");
var graphql_1 = require("graphql");
var resources_1 = require("./resources");
var graphql_dynamodb_transformer_1 = require("graphql-dynamodb-transformer");
var graphql_transformer_common_1 = require("graphql-transformer-common");
var graphql_transformer_common_2 = require("graphql-transformer-common");
var definitions_1 = require("./definitions");
function makeConnectionAttributeName(type, field) {
    return field ? graphql_transformer_common_1.toCamelCase([type, field, 'id']) : graphql_transformer_common_1.toCamelCase([type, 'id']);
}
function validateKeyField(field) {
    if (!field) {
        return;
    }
    var baseType = graphql_transformer_common_1.getBaseType(field.type);
    var isAList = graphql_transformer_common_1.isListType(field.type);
    // The only valid key fields are single String and ID fields.
    if ((baseType === 'ID' || baseType === 'String') &&
        (!isAList)) {
        return;
    }
    throw new graphql_transformer_core_1.InvalidDirectiveError("If you define a field and specify it as a 'keyField', it must be of type 'ID' or 'String'.");
}
/**
 * The @connection transform.
 *
 * This transform configures the GSIs and resolvers needed to implement
 * relationships at the GraphQL level.
 */
var ModelConnectionTransformer = /** @class */ (function (_super) {
    __extends(ModelConnectionTransformer, _super);
    function ModelConnectionTransformer() {
        var _this = _super.call(this, 'ModelConnectionTransformer', "directive @connection(name: String, keyField: String, sortField: String) on FIELD_DEFINITION") || this;
        _this.before = function (ctx) {
            var template = _this.resources.initTemplate();
            ctx.mergeResources(template.Resources);
            ctx.mergeParameters(template.Parameters);
            ctx.mergeOutputs(template.Outputs);
        };
        /**
         * Create a 1-1, 1-M, or M-1 connection between two model types.
         * Throws an error if the related type is not an object type annotated with @model.
         */
        _this.field = function (parent, field, directive, ctx) {
            var parentTypeName = parent.name.value;
            var fieldName = field.name.value;
            var parentModelDirective = parent.directives.find(function (dir) { return dir.name.value === 'model'; });
            if (!parentModelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError("@connection must be on an @model object type field.");
            }
            var relatedTypeName = graphql_transformer_common_1.getBaseType(field.type);
            var relatedType = ctx.inputDocument.definitions.find(function (d) { return d.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION && d.name.value === relatedTypeName; });
            if (!relatedType) {
                throw new graphql_transformer_core_1.InvalidDirectiveError("Could not find an object type named " + relatedTypeName + ".");
            }
            var modelDirective = relatedType.directives.find(function (dir) { return dir.name.value === 'model'; });
            if (!modelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError("Object type " + relatedTypeName + " must be annotated with @model.");
            }
            var connectionName = graphql_transformer_common_1.getDirectiveArgument(directive)("name");
            var associatedSortFieldName = null;
            var sortType = null;
            // Find the associated connection field if one exists.
            var associatedConnectionField = relatedType.fields.find(function (f) {
                var relatedDirective = f.directives.find(function (dir) { return dir.name.value === 'connection'; });
                if (relatedDirective) {
                    var relatedDirectiveName = graphql_transformer_common_1.getDirectiveArgument(relatedDirective)("name");
                    if (connectionName && relatedDirectiveName && relatedDirectiveName === connectionName) {
                        associatedSortFieldName = graphql_transformer_common_1.getDirectiveArgument(relatedDirective)('sortField');
                        return true;
                    }
                }
                return false;
            });
            if (connectionName && !associatedConnectionField) {
                throw new graphql_transformer_core_1.InvalidDirectiveError("Found one half of connection \"" + connectionName + "\" at " + parentTypeName + "." + fieldName + " but no related field on type " + relatedTypeName);
            }
            connectionName = connectionName || parentTypeName + "." + fieldName;
            var leftConnectionIsList = graphql_transformer_common_1.isListType(field.type);
            var leftConnectionIsNonNull = graphql_transformer_common_1.isNonNullType(field.type);
            var rightConnectionIsList = associatedConnectionField ? graphql_transformer_common_1.isListType(associatedConnectionField.type) : undefined;
            var rightConnectionIsNonNull = associatedConnectionField ? graphql_transformer_common_1.isNonNullType(associatedConnectionField.type) : undefined;
            var connectionAttributeName = graphql_transformer_common_1.getDirectiveArgument(directive)("keyField");
            var associatedSortField = associatedSortFieldName &&
                parent.fields.find(function (f) { return f.name.value === associatedSortFieldName; });
            if (associatedSortField) {
                if (graphql_transformer_common_1.isListType(associatedSortField.type)) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError("sortField \"" + associatedSortFieldName + "\" is a list. It should be a scalar.");
                }
                sortType = graphql_transformer_common_1.getBaseType(associatedSortField.type);
                if (!graphql_transformer_common_1.isScalar(associatedSortField.type) || sortType === graphql_transformer_common_1.STANDARD_SCALARS.Boolean) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError("sortField \"" + associatedSortFieldName + "\" is of type \"" + sortType + "\". " +
                        "It should be a scalar that maps to a DynamoDB \"String\", \"Number\", or \"Binary\"");
                }
            }
            // Relationship Cardinalities:
            // 1. [] to []
            // 2. [] to {}
            // 3. {} to []
            // 4. [] to ?
            // 5. {} to ?
            if (leftConnectionIsList && rightConnectionIsList) {
                // 1. TODO.
                // Use an intermediary table or other strategy like embedded string sets for many to many.
                throw new graphql_transformer_core_1.InvalidDirectiveError("Many to Many connections are not yet supported.");
            }
            else if (leftConnectionIsList && rightConnectionIsList === false) {
                // 2. [] to {} when the association exists. Note: false and undefined are not equal.
                // Store a foreign key on the related table and wire up a Query resolver.
                // This is the inverse of 3.
                if (!connectionAttributeName) {
                    connectionAttributeName = makeConnectionAttributeName(relatedTypeName, associatedConnectionField.name.value);
                }
                // Validate the provided key field is legit.
                var existingKeyField = relatedType.fields.find(function (f) { return f.name.value === connectionAttributeName; });
                validateKeyField(existingKeyField);
                var queryResolver = _this.resources.makeQueryConnectionResolver(parentTypeName, fieldName, relatedTypeName, connectionAttributeName, connectionName);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.ResolverResourceID(parentTypeName, fieldName), queryResolver);
                _this.extendTypeWithConnection(ctx, parent, field, relatedType);
            }
            else if (!leftConnectionIsList && rightConnectionIsList) {
                // 3. {} to [] when the association exists.
                // Store foreign key on this table and wire up a GetItem resolver.
                // This is the inverse of 2.
                // if the sortField is not defined as a field, throw an error
                // Cannot assume the required type of the field
                if (associatedSortFieldName && !associatedSortField) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError("sortField \"" + associatedSortFieldName + "\" not found on type \"" + parent.name.value + "\", other half of connection \"" + connectionName + "\".");
                }
                if (!connectionAttributeName) {
                    connectionAttributeName = makeConnectionAttributeName(parentTypeName, fieldName);
                }
                // Validate the provided key field is legit.
                var existingKeyField = parent.fields.find(function (f) { return f.name.value === connectionAttributeName; });
                validateKeyField(existingKeyField);
                var tableLogicalId = graphql_transformer_common_2.ModelResourceIDs.ModelTableResourceID(parentTypeName);
                var table = ctx.getResource(tableLogicalId);
                var sortField = associatedSortField ? { name: associatedSortFieldName, type: sortType } : null;
                var updated = _this.resources.updateTableForConnection(table, connectionName, connectionAttributeName, sortField);
                ctx.setResource(tableLogicalId, updated);
                var getResolver = _this.resources.makeGetItemConnectionResolver(parentTypeName, fieldName, relatedTypeName, connectionAttributeName);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.ResolverResourceID(parentTypeName, fieldName), getResolver);
                // Update the create & update input objects for this
                var createInputName = graphql_transformer_common_2.ModelResourceIDs.ModelCreateInputObjectName(parentTypeName);
                var createInput = ctx.getType(createInputName);
                if (createInput) {
                    var updated_1 = definitions_1.updateCreateInputWithConnectionField(createInput, connectionAttributeName, leftConnectionIsNonNull);
                    ctx.putType(updated_1);
                }
                var updateInputName = graphql_transformer_common_2.ModelResourceIDs.ModelUpdateInputObjectName(parentTypeName);
                var updateInput = ctx.getType(updateInputName);
                if (updateInput) {
                    var updated_2 = definitions_1.updateUpdateInputWithConnectionField(updateInput, connectionAttributeName);
                    ctx.putType(updated_2);
                }
            }
            else if (leftConnectionIsList) {
                // 4. [] to ?
                // Store foreign key on the related table and wire up a Query resolver.
                // This has no inverse and has limited knowlege of the connection.
                if (!connectionAttributeName) {
                    connectionAttributeName = makeConnectionAttributeName(parentTypeName, fieldName);
                }
                // Validate the provided key field is legit.
                var existingKeyField = relatedType.fields.find(function (f) { return f.name.value === connectionAttributeName; });
                validateKeyField(existingKeyField);
                var tableLogicalId = graphql_transformer_common_2.ModelResourceIDs.ModelTableResourceID(relatedTypeName);
                var table = ctx.getResource(tableLogicalId);
                var updated = _this.resources.updateTableForConnection(table, connectionName, connectionAttributeName);
                ctx.setResource(tableLogicalId, updated);
                var queryResolver = _this.resources.makeQueryConnectionResolver(parentTypeName, fieldName, relatedTypeName, connectionAttributeName, connectionName);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.ResolverResourceID(parentTypeName, fieldName), queryResolver);
                _this.extendTypeWithConnection(ctx, parent, field, relatedType);
                // Update the create & update input objects for the related type
                var createInputName = graphql_transformer_common_2.ModelResourceIDs.ModelCreateInputObjectName(relatedTypeName);
                var createInput = ctx.getType(createInputName);
                if (createInput) {
                    var updated_3 = definitions_1.updateCreateInputWithConnectionField(createInput, connectionAttributeName);
                    ctx.putType(updated_3);
                }
                var updateInputName = graphql_transformer_common_2.ModelResourceIDs.ModelUpdateInputObjectName(relatedTypeName);
                var updateInput = ctx.getType(updateInputName);
                if (updateInput) {
                    var updated_4 = definitions_1.updateUpdateInputWithConnectionField(updateInput, connectionAttributeName);
                    ctx.putType(updated_4);
                }
            }
            else {
                // 5. {} to ?
                // Store foreign key on this table and wire up a GetItem resolver.
                // This has no inverse and has limited knowlege of the connection.
                if (!connectionAttributeName) {
                    connectionAttributeName = makeConnectionAttributeName(parentTypeName, fieldName);
                }
                // Validate the provided key field is legit.
                var existingKeyField = parent.fields.find(function (f) { return f.name.value === connectionAttributeName; });
                validateKeyField(existingKeyField);
                var getResolver = _this.resources.makeGetItemConnectionResolver(parentTypeName, fieldName, relatedTypeName, connectionAttributeName);
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.ResolverResourceID(parentTypeName, fieldName), getResolver);
                // Update the create & update input objects for this type
                var createInputName = graphql_transformer_common_2.ModelResourceIDs.ModelCreateInputObjectName(parentTypeName);
                var createInput = ctx.getType(createInputName);
                if (createInput) {
                    var updated = definitions_1.updateCreateInputWithConnectionField(createInput, connectionAttributeName, leftConnectionIsNonNull);
                    ctx.putType(updated);
                }
                var updateInputName = graphql_transformer_common_2.ModelResourceIDs.ModelUpdateInputObjectName(parentTypeName);
                var updateInput = ctx.getType(updateInputName);
                if (updateInput) {
                    var updated = definitions_1.updateUpdateInputWithConnectionField(updateInput, connectionAttributeName);
                    ctx.putType(updated);
                }
            }
        };
        _this.resources = new resources_1.ResourceFactory();
        return _this;
    }
    ModelConnectionTransformer.prototype.typeExist = function (type, ctx) {
        return Boolean(type in ctx.nodeMap);
    };
    ModelConnectionTransformer.prototype.generateModelXConnectionType = function (ctx, typeDef) {
        var tableXConnectionName = graphql_transformer_common_2.ModelResourceIDs.ModelConnectionTypeName(typeDef.name.value);
        if (this.typeExist(tableXConnectionName, ctx)) {
            return;
        }
        // Create the ModelXConnection
        var connectionType = graphql_transformer_common_1.blankObject(tableXConnectionName);
        ctx.addObject(connectionType);
        ctx.addObjectExtension(graphql_dynamodb_transformer_1.makeModelConnectionType(typeDef.name.value));
    };
    ModelConnectionTransformer.prototype.extendTypeWithConnection = function (ctx, parent, field, returnType) {
        this.generateModelXConnectionType(ctx, returnType);
        // Extensions are not allowed to redeclare fields so we must replace
        // it in place.
        var type = ctx.getType(parent.name.value);
        if (type &&
            (type.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || type.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION)) {
            // Find the field and replace it in place.
            var newFields = type.fields.map(function (f) {
                if (f.name.value === field.name.value) {
                    var updated = graphql_dynamodb_transformer_1.makeModelConnectionField(field.name.value, returnType.name.value);
                    updated.directives = f.directives;
                    return updated;
                }
                return f;
            });
            var updatedType = __assign({}, type, { fields: newFields });
            ctx.putType(updatedType);
            if (!this.typeExist('ModelSortDirection', ctx)) {
                var modelSortDirection = graphql_dynamodb_transformer_1.makeModelSortDirectionEnumObject();
                ctx.addEnum(modelSortDirection);
            }
            this.generateFilterInputs(ctx, returnType);
        }
        else {
            throw new graphql_transformer_core_1.InvalidDirectiveError("Could not find a object or interface type named " + parent.name.value + ".");
        }
    };
    ModelConnectionTransformer.prototype.generateFilterInputs = function (ctx, field) {
        var scalarFilters = graphql_dynamodb_transformer_1.makeScalarFilterInputs();
        for (var _i = 0, scalarFilters_1 = scalarFilters; _i < scalarFilters_1.length; _i++) {
            var filter = scalarFilters_1[_i];
            if (!this.typeExist(filter.name.value, ctx)) {
                ctx.addInput(filter);
            }
        }
        // Create the ModelXFilterInput
        var tableXQueryFilterInput = graphql_dynamodb_transformer_1.makeModelXFilterInputObject(field);
        if (!this.typeExist(tableXQueryFilterInput.name.value, ctx)) {
            ctx.addInput(tableXQueryFilterInput);
        }
    };
    return ModelConnectionTransformer;
}(graphql_transformer_core_1.Transformer));
exports.ModelConnectionTransformer = ModelConnectionTransformer;
//# sourceMappingURL=ModelConnectionTransformer.js.map